#include<reg52.h>                                     //header file

sbit en_ip1=P1^4;                                    //all four variables are used to enable inputs buffers
sbit en_ip2=P1^3;
sbit en_ip3=P1^2;
sbit en_ip4=P1^5;

sbit en_op1=P3^0;                                    //all three variables are used to enable output buffers
sbit en_op2=P3^1;

sbit sw1=P3^4;                                       //three switches for floor settings
sbit sw2=P3^5;
sbit sw3=P3^6;

sbit cam=P2^0;                                    //to operate P2 as a single bit
sbit up=P2^1;
sbit buzz=P2^3;
sbit fans=P2^4;
sbit down=P2^5;
sbit seco_spee=P2^6;


unsigned char ip1;                                     //four variables for four inputs
unsigned char ip2;
unsigned char ip3;
unsigned char ip4;

unsigned char car;                                   //a variable showing position of cabin
unsigned char call_car;                              //in call variable if any bit is one then that call is pendind
unsigned char call_lan;                        //in call variable if any bits is one then that call is pendind
unsigned char call;                            //in call variable if any bits is one then that call is pendind
unsigned char car_desti;                   //it is a next destination for car

void en_op_fun(bit op,unsigned char temp);         //output function
unsigned char en_ip_fun(bit ip1,bit ip2);          //input function
unsigned char op2_fun();                              //output function for seven segment
void ms_delay(unsigned int time);                     //delay functions

unsigned int fan,stand,car_buzzer,car_buzzer2,ram,rams,buzzer_on_count,critical,car_cancel,buzz_count;
unsigned char i,temp,temp2,k,blink,blink_seven,ram_count,ram_counts,floor,multi,floor_nos;
bit start,desti_change,ready,stop,fire,maintain,AA,disp,ram_flip,ram_flips,cl,stand_or_not,open,seco_speev,uord;

void main()                                           //output is accordingly negative logic
{
	en_ip1=1;                                          //(negative level trigger)initialisation of enables of input buffers
	en_ip2=1;
	en_ip3=1;
	en_ip4=1;
	
	en_op1=0;                                          //(positive edge trigger)initialisation of enables of output buffers
	en_op2=0;
	   	
	en_op_fun(0,0xFF);                       //initialisation of output port-1
  en_op_fun(1,0xFF);                      //initialisation of output port-2
	P2=0xFF;                                //initialisation of output port-3 
	ms_delay(1);                      
	
	call_car=0x00;                         //call and destination parameters initialisation
	call_lan=0x00;
	call=0x00;
	car_desti=0x00;
	
	fan = 0;                               //integers
	stand =0;
	car_buzzer=0;                        //for (010101) if car gate is open
	car_buzzer2=0;                       //for time pass car gate is open
	ram=0;
	rams=0;
	buzzer_on_count=0;
	critical=0x00;
	car_cancel=0;
	buzz_count=0;
	
	blink=0;                              //chars
	blink_seven=0;
	ram_count=0;
	ram_counts=0;
	
	start=0;                             //to ckeck till when we need to drive the car till it ends to one of the the floor
	desti_change=1;                      //desination can be changed
	ready = 1;                           //car is ready to take second call                      
	fire = 0;                            //if fire button is once pressed it becomes 1
	maintain = 0;                        //if maintainance bits of ip is high then it is high
	AA=0;                               //if maintainance bits of ip is high then it is high
	disp=0;                             //if bits is 0 then it display floor otherwise display othen thing
	ram_flip=0;                         //if bits is 0 then cam is ON otherwise it is OFF 
	ram_flips=0;                        //if bits is 0 then cam is ON otherwise it is OFF
	cl=0;                               //if cl==1 then dispaly "C" otherwise "L"
	stand_or_not=0;                     //for standing delay
	open=0;                             //to dispaly landing door after closing car door
	seco_speev=0;                       //for mis match of D OFF ip
	                                    
																			
																			//floor_nos
	
	temp2 = P3 & 0x70;                  //to decide how many floors are there
	switch(temp2)
	{
	  case 0x60:
		{
			floor=0x83;                      //floor contain multiplication term with 7th bits
			multi=0x02;                          //multi cantain the no of floors in building
			floor_nos=0x03;                          //floor_nos contain multiplication term without 7th bits
			break;
		}
		case 0x50:
		{
			multi=0x04;
			floor=0x87;
			floor_nos=0x07;
			break;
		}
		case 0x40:
		{
			multi=0x08;
			floor=0x8F;
			floor_nos=0x0F;
			break;
		}
		case 0x30:
		{
			multi=0x10;
			floor=0x9F;
			floor_nos=0x1F;
			break;
		}
		case 0x20:
		{
			multi=0x20;
			floor=0xBF;
			floor_nos=0x3F;
			break;
		}
		case 0x10:
		{
			multi=0x40;
			floor=0xFF;
			floor_nos=0x7F;
			break;
		}
		case 0x00:
		{
			multi=0x80;
			floor=0xFF;
			floor_nos=0xFF;
			break;
		}
		default:
		{
			floor=0x00;
			multi=0;
			floor_nos=0x00;
		}
	}	
	
	//1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	ip1=en_ip_fun(0,0);
	ip1 = ip1 & floor;
	ip4=en_ip_fun(1,1);
	
	temp = ip4 & 0x80;
	if(temp != 0x80 || ip1 == 0x00) 
	{
		while(start!=1)
		{
      ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x01;     //for car door
			temp2 = ip4 & 0x02;    //for landing door
			i = ip4 & 0x40;        //stop
			k= ip4 & 0x20;         //maintainance
			
			if(i == 0x40)         //for stop
			{
				 P2= 0xFF;
			   ms_delay(1);
				 ram=0;
				 ram_flip=0;
				 ram_count=0;
			}
			else
			{
			  if(k==0x20)            //for maintainance
			  {
					maintain=1;
				  
					ip2 = en_ip_fun(0,1);
					temp = ip2 & 0x03;    //to take command of up or down in maintainance
				
				  en_op_fun(0,~temp);  //to indicate at op1 in maintainance
				
				  ip4=en_ip_fun(1,1);   //to find any door is open or not
		      temp2=ip4 & 0x03;
				  if(temp2 == 0x03)
					{
					  if(temp == 0x01)      //if command to go down in maintainance
		        {
						  if(cam==1)
						  {
						    cam=0;
                ms_delay(40);
						  }
              P2 = 0xDE;
              ms_delay(1);
              uord=1;						
 	          }
			      else if(temp == 0x02)  //if command to go up in maintainance
			      {
						  if(cam==1)
						  {
			          cam=0;
						    ms_delay(40);
					  	}
						  P2=0xFC;
						  ms_delay(1);
						  uord=0;
		        }
					  else                  //if both command at a time or no command at a time
					  {
							P2=P2 | 0xFE;
			        ms_delay(1);
						  if(cam==0)
						  {
								ms_delay(40);
						    cam=1;
                ms_delay(1);
						  }
					  }
				  }
			  }
				else if(maintain==1 && k!=0x20)  //to come out from maintainance
				{
					maintain=0;
					P2 = 0xFF;
					ms_delay(1);
					ram=0;
					ram_flip=0;
					ram_count=0;
					en_op_fun(0,0xFF);
					ms_delay(1000);
				}
	
			  else if(temp == 0x01 && temp2 == 0x02)  //to go down in initialisation
			  {
				  ram_count=0;
				  ram=0;
				  ram_flip=0;
					if(cam==1)
					{	
			      cam=0;
					  ms_delay(40);
					}
			    P2 = 0x8E;
          ms_delay(1);
          uord=1;					
			  }
				
			  else if(temp == 0x01 && temp != 0x02)
			  {
				  P2 = P2 | 0x72;               //to stop up and down command
				  ms_delay(1);
				  if(ram_flip == 0)             //cam on-off
				  {
            cam=0;
						ms_delay(1);					
				  }
				  else
				  {	 
						cam=1;
				    ms_delay(1);
				  }
				  if(ram_count != 5)
            ram++;
          if(ram == 35)
          {
            ram = 0;
					  ram_count++;
					  ram_flip = ~ram_flip;
				  }
          if(ram_count==5)
			 	  {
						buzz=0;
					  ms_delay(1);
				  }					
			  }	
				
        else
			  {
				  ram_count=0;
				  ram=0;
				  ram_flip=0;
				  P2 = P2 | 0x73;
				  ms_delay(1);
          car_buzzer++;
				  if(car_buzzer == 300)
				  {
					  car_buzzer = 0;
						buzz=0;
            ms_delay(1);					
				  }
			  }
		  }
			
			
			ip4 = en_ip_fun(1,1);  //for seven segment
			temp = ip4 & 0x01;
			temp2 = ip4 & 0x02;
			k= ip4 & 0x20;     //maintainance
			
			if(k==0x20)
			  en_op_fun(1,0xAA);     //To indicate "M"
			else if(temp!=0x01)
				en_op_fun(1,0xC6);       //to indicate  "C"
			else if(temp2!=0x02)
				en_op_fun(1,0xC7);       //to indicate  "L"
			else
				en_op_fun(1,0xFF);
			
      ip4 = en_ip_fun(1,1);      //to high start bits
      temp = ip4 & 0x80;
			
			ip1=en_ip_fun(0,0);
			ip1 = ip1 & floor;
			
      if(temp == 0x80 && ip1 != 0x00)
        start =1;
	  }
	}
	
	P2 = 0xFF;                       
	ms_delay(1);
  ip1 = en_ip_fun(0,0);           //to decide where is lift and disp it
	ip1 = ip1 & floor;
	temp = ip1 & 0x80;
	if(temp != 0x00)
	{
		ip1 = ip1 | multi;
		ip1 = ip1 & 0x7F;
	}
	car=ip1;
	en_op_fun(1,op2_fun());
	maintain=0;
	ram=0;
	ram_count=0;
	ram_flip=0;
	
	while(1)
	{
		//2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 
		ip1=en_ip_fun(0,0);
		ip1 = ip1 & floor;
		
		temp = ip1 & 0x80;
		if(temp != 0x00)
		{
			ip1 = ip1 | multi;
			ip1 = ip1 & 0x7F;
		}
		if(ip1!=0x00 && ip1!=0x01 && ip1!=0x02 && ip1!=0x04 && ip1!=0x08 && ip1!=0x10 && ip1!=0x20 && ip1!=0x40 && ip1!=0x80 && fire==0 && maintain==0)
		{                                                  //to reed at a time
			P2=0xFF;                                          //then  initialize all things
			ms_delay(1);
		  call_car = 0x00;
		  call_lan = 0x00;
			call = 0x00;
			car_desti = 0x00;
			fan=0;
			buzz_count=0;
			stand=0;
			car_buzzer=0;
			car_buzzer2=0;
			ram=0;
			ram_count=0;
			ram_flip=0;
			rams=0;
			ram_counts=0;
			ram_flips=0;
			buzzer_on_count=0;
			critical=0;
			car_cancel=0;
			desti_change=1;
			ready=1;
		}
		else if(ip1 != 0x00)
		{	
		  car=ip1;
			ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x80;
			temp2 = ip4 & 0x03;
			if(car == car_desti && seco_spee ==1 && temp != 0x80 && temp2 == 0x03)   //if there is not second speed and if it is destination 
			{                                                                        //then give second speed
				seco_spee=0;
				ms_delay(1);
				desti_change=0;
			}
			if(car!=car_desti && seco_spee==0 && temp2 == 0x03)                       //if car have already second speed and destination 
			{                                                                 //is not that floor then
				car_desti = car;
				call_car = call_car | car;
				call = call_car | call_lan;
			}
		}
		//3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
		ip2=en_ip_fun(0,1);                 
		ip2 = ip2 & floor_nos;
		ip2= ip2 & (~car);
		call_car= call_car | ip2;
		//4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
		ip3=en_ip_fun(1,0);                   
		ip3 = ip3 & floor_nos;
		ip3 =ip3 & (~car);
		call_lan= call_lan | ip3;
		
		call= call_car | call_lan;
		//5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
		if(call != 0x00 && desti_change==1)    //***********************************************************************************************************************************************************************
		{
		  if(up==1 && down==1)                                //if car is stop******************************************************************************************************************************************
		  {
			  if(call_car != 0x00 && call_lan != 0x00)         //both car and lan call at a time
			  {
					if(car > call_car && car > call_lan)           //(3.2)car will go down because call_car is down and call_lan is down
					{
						temp = call_car | call_lan;
						for(i=0;i<8;i++)
						{
							temp2 = temp & (0x80 >> i);
							if(temp2 != 0x00)
								break;
						}
						car_desti=temp2;
					}
					else                                          //car will go up bcoz atleast one call is upwards
					{                                             
						if(call_car > car)                          //(3.1,3.3)car will go to lowest call_car higher than car
						{
						  for(i=0;i<8;i++)
						  {
							  temp = car & (0x01 << i);
							  if(temp != 0x00)
								  break;
						  }
						  for(k=i+1 ; k<8 ; k++)
						  {
							  temp = call_car & (0x01 << k);
							  if(temp != 0x00)
								  break;
						  }
							car_desti = temp;
					  }
						else                                         //(3.4)car will go up to attend call_lan
							{
							  for(i=0;i<8;i++)
							  {
								  temp = call_lan & (0x80>>i);
								  if(temp != 0x00)
									  break;
							  }
							  car_desti = temp;
						  }
					  }
			    }
			    else if(call_lan != 0x00)                        //both lan call is at a time
				  {
					  if(call_lan > car)                              //(2.1,2.3)car will go up
					{
						for(i=0;i<8;i++)
						{
							temp = call_lan & (0x80 >> i);
							if(temp != 0x00)
								break;
						}
						car_desti = temp;
					}
					else                                            //(2.2)car will go down
					{
						for(i=0;i<8;i++)
						{
							temp = car & (0x80 >> i);
							if(temp != 0x00)
								break;
						}
						for(k=i+1 ; k<8;k++)
						{
							temp = call_lan & ( 0x80 >> k);
							if(temp != 0x00)
								break;
						}
						car_desti = temp;
					}
				}
				else if(call_car != 0x00)                         //both call_car at a time
				{
					if(call_car < car)                               //(1.2)car will go down
					{
						for(i=0;i<8;i++)
						{
							temp = call_car & (0x80>>i);
							if(temp != 0x00)
								break;
						}
						car_desti = temp;
					}
					else                                             //(1.1,1.3)car will go up
					{
						for(i=0;i<8;i++)
						{
							temp = car & (0x01 << i);
							if(temp != 0x00)
								break;
						}
						for(k=i+1;k<8;k++)
						{
							temp = call_car & (0x01 << k);
							if(temp != 0x00)
								break;
						}
						car_desti=temp;
					}
				}
		  }
		  else if(up==0)                           //if car is going up****************************************************************************************************************************************************
		  {
				if(call_car != 0x00)                   //there ia at least one call_car
				{
					for(i=0;i<8;i++)
					{
						temp = car & (0x01 << i);
						if(temp != 0x00)
							break;
					}
					for(k=i+1;k<8;k++)
					{
						temp = call_car & (0x01 << k);
						if(temp != 0x00)
							break;
					}
					car_desti=temp;
				}	
        else                                   //there is no call_car only call_lan
				{
          for(i=0;i<8;i++)
					{
						temp = call_lan & (0x80>>i);
						if(temp != 0x00)
							break;
					}
					car_desti=temp;
				}					
		  }
		  else if(down==0)                          //if car is going down****************************************************************************************************************************************************
		  {
				temp = call_car | call_lan;
				for(i=0;i<8;i++)
				{
					temp2 = car & (0x80>>i);
					if(temp2 != 0x00)
						break;
		    }
				for(k=i+1;k<8;k++)
				{
					temp2 = temp & (0x80 >> k);
					if(temp2 != 0x00)
						break;
				}
				car_desti = temp2;
			}
		  else                                       //if critical condition
		  {
			  P2=0xFF;
			  ms_delay(2);
	    }
			temp = car_desti & call;
			if(temp == 0x00)
			{
				//P2 = P2 & 0xBF;
				seco_spee=0;
				ms_delay(1);
			}
		}
	  
		
		
		//(0101010101010101010101010101010101010101010101010101010101010101)6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
		ip4=en_ip_fun(1,1); 
		
		if(ready == 1 && car_desti != 0x00)
		{
			ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x01;               //for car gate
			temp2 = ip4 & 0x02;               //for landing gate
			if(temp == 0x01 && temp2 == 0x02)  //if all gates are closed
			{
				if(cam==1)
				{
				  cam=0;
			    ms_delay(40);	
				}
				ram=0;
				ram_flip=0;
				ram_count=0;
				car_cancel=0;
				if(car < car_desti)            //during full speed
			  {
			    P2=0xEC;
			    ms_delay(1);
					uord=0;
		    }
		    else if (car > car_desti)
		    {
			    P2=0xCE;
				  ms_delay(1);
					uord=1;
			  }
			  else if(car == car_desti)
				{
          if(uord==0)
					{
						P2=0xAC;
						ms_delay(1);
					}
					else
					{
						P2=0x8E;
						ms_delay(1);
					}
				}										
			}
			
			else if(temp == 0x01 && temp != 0x02)
			{
				P2 = P2 | 0x62;
				ms_delay(1);
				fans=0;                                //fan ON because there is a call
				ms_delay(1);
				car_cancel=0;
				if(ram_flip == 0)                        //cam ON-OFF
				{
					cam=0;
					ms_delay(1);					
				}
				else
				{	
				  cam=1;
					ms_delay(1);
			  }
				
			 	if(ram_count != 5)
          ram++;
				
        if(ram == 35)                        //fliping of cam
        {
          ram = 0;
					ram_count++;
					ram_flip = ~ram_flip;
				}
				if(ram_count==3)                  //on the buzzer
				{
					buzz=0;
					ms_delay(1);
				}
        if(ram_count==5)                       //initialize again                
				{
					cam=1;
					ms_delay(1);
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					ram_count=0;
					ram=0;
					ram_flip=0;
					if(maintain==0 && fire==0)
						desti_change=1;
				}					
			}
			
      else                       //if car gate is open
			{
				P2 = P2 | 0x63;           //cam should be off
				ms_delay(1);
				fans=0;
				ms_delay(1);
				ram=0;
				ram_flip=0;                    
				ram_count=0;
				
        car_buzzer++;             // to on buzzer if car gate is open
				if(car_buzzer == 100)
				{
					car_buzzer = 0;
          buzz=0;
					ms_delay(1);					
				}
				
				car_cancel++;             
				if(car_cancel==250)       //to cancle all calls due to car gate open
				{
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					car_cancel=0;
					if(maintain==0 && fire==0)
						desti_change=1;
				}
			}
		}
		
		
		/*ip4=en_ip_fun(1,1);                          //AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA
		temp = ip4 & 0x04;
		if(temp == 0x04)
		{//dont use temp inside the function
			if(AA==0)
			{
				AA=1;
			  desti_change=0;
			  call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				main_desti_change=1;
			}
			else
			{
				if(call_car != pre_desti)
				{
					P2 = P2 & 0x7F;
					ms_delay(10);
				}
				pre_desti=call_car;
				
			}
		}
		else if(temp != 0x04 && AA==1)
		{
			AA=0;
			desti_change=1;
			pre_desti=0x00;
		}*/
		
		//(fire fire fire fire fire fire fire fire fire fire)7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 
		ip4 = en_ip_fun(1,1);                
		temp = ip4 & 0x10;
		if(((temp == 0x10 && maintain==0) || fire==1) && stop==0)
		{
			if(fire==0)                        //initialise maintainance
			{
				P2= 0xFF;
			  ms_delay(1);
				desti_change=0;
				call_car = 0x01;                //give command to go at ground
		    call_lan = 0x00;
			  call = 0x01;
			  car_desti = 0x01;
				fire=1;
				ready=1;
			}
			desti_change=0;
			call_car = 0x01;
		  call_lan = 0x00;
			call = 0x01;
			car_desti = 0x01;
			ready=1;
		}
		
		//(maintain maintain maintain maintain maintain maintain maintain)8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
		ip4 = en_ip_fun(1,1);
		temp = ip4 & 0x20;
		if(temp == 0x20 && fire==0)
		{
			if(maintain==0)                               //initialisation of maintainance
			{
				P2= 0xFF;
				ms_delay(1);
				desti_change=0;
				maintain=1;
				ready=0;
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
			}
			else
			{
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				ip2 = en_ip_fun(0,1);
		    k = ip2 & 0x03;
				
				en_op_fun(0,~k);
				
				ip4=en_ip_fun(1,1);
		    temp2=ip4 & 0x43;
				
				if(temp2 == 0x03)                        //checking of all doors close
			  {
					if(k == 0x01)                        //give command to go down
		        {
              if(cam==1)
							{
								cam=0;
							  ms_delay(40);
							}
              P2 = 0xDE;
              ms_delay(1);							
							uord=1;
 	          }
			      else if(k == 0x02)                //give command to go up
			      {
							if(cam==1)
							{
			          cam=0;
							  ms_delay(40);
							}
							P2=0xFC;
							ms_delay(1);
							uord=0;
		        }
					else                             //no command or both command at a time
					{
						P2=P2 | 0xFE;
			      ms_delay(1);
						if(cam==0)
						{
							ms_delay(40);
						  cam=1;
              ms_delay(1);
						}
					}
			  }
				else
			  {
			    P2=0xFF;
				  ms_delay(1);
		    }
		  }
		}
		else if(temp != 0x20 && maintain==1)       //endind of maintainance
		{
			P2=0xFF;
			ms_delay(1);
			call_car=0x00;
	    call_lan=0x00;
	    call=0x00;
	    car_desti=0x00;
	    fan = 0;
			buzz_count=0;
			stand =0;
	    car_buzzer=0;
	    car_buzzer2=0;
	    ram=0;
	    rams=0;
	    buzzer_on_count=0;
	    critical=0x00;
	    car_cancel=0;
	    blink=0;
	    blink_seven=0;
	    ram_count=0;
	    ram_counts=0;
	    desti_change=1;          
	    ready = 1;                                     
	    fire = 0;                
	    maintain = 0;            
	    disp=0;                  
	    ram_flip=0;   
	    ram_flips=0; 
	    cl=0;        
	    stand_or_not=0;
	    open=0;        
	    seco_speev=0;
			ms_delay(1000);
		}
		
	
		//(stop stop stop stop stop stop stop stop stop)9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 
		temp = ip4 & 0x40;                        
		if(temp == 0x40)
		{
			if(stop==0)                       //give stop command in  any condition
			{
			  P2= 0xFF;
			  ms_delay(1);
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				stop=1;
				desti_change=0;
				ready=0;
			}
			else
			{
				P2= 0xFF;
			  ms_delay(1);
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
			}
		}
		else if(temp!=0x40 && stop==1)   //ending of stop
		{
			stop=0;
	    fan = 0;
			buzz_count=0;
			stand =0;
	    car_buzzer=0;
	    car_buzzer2=0;
	    ram=0;
	    rams=0;
	    buzzer_on_count=0;
	    critical=0x00;
	    car_cancel=0;
	    blink=0;
	    blink_seven=0;
	    ram_count=0;
	    ram_counts=0;                                                       
	    disp=0;                  
	    ram_flip=0;   
	    ram_flips=0; 
	    cl=0;        
	    stand_or_not=0;
	    open=0;        
	    seco_speev=0;
			if(fire==0 && maintain==0)
			{
				call_car=0x00;
	      call_lan=0x00;
	      call=0x00;
	      car_desti=0x00;
				ready=1;
			  desti_change=1;
			}
			else if(maintain==1)
			{
				P2= 0xFF;
			  ms_delay(1);
				desti_change=0;
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				ready=0;
			}
			else if(fire==1)
			{
				P2= 0xFF;
			  ms_delay(1);
				desti_change=0;
				call_car = 0x01;
		    call_lan = 0x00;
			  call = 0x01;
			  car_desti = 0x01;
				ready=1;
			}
		}
	
	
		 //(777777777777777777777777777777777777777777777777777777)10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 
		temp = ip4 & 0x80;                      
		if(temp == 0x80)
		{
			if(seco_spee == 0)                          //to check for second speed
			{ 
        P2=0xEE;
			  ms_delay(40);
				cam=1;
				ms_delay(1);
			
				call_car = call_car & (~car);           //erase this car from
			  call_lan = call_lan & (~car);
				call=call_car | call_lan;
				car_desti=0x00;
				
				ip4 = en_ip_fun(1,1);              //for lift man and fire
		    temp = ip4 & 0x04;
			  if(temp == 0x00 && fire==0 && maintain==0)                      
		      desti_change=1;
				
				stand_or_not=1;        //for standing delay
			}
		}
		if(stand_or_not==1)           //for standing delay
		{
			stand++;
			if(stand==100)
			{
				stand=0;
				ready=1;
				stand_or_not=0;
			}
			else 
				ready=0;
			}
	
			//(critical critical critical critical)11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 111 11 11 11 11 11 11 11 11  
		 if((up==0 || down==0) && maintain==0)                       
		{
			ip1=en_ip_fun(0,0);           //this code is for that car is going up or down and not getting reed
			ip1 =ip1 & floor;             //so this is critical situation so stop every things and restart it
			if(ip1==0x00)
				critical++;
			else
			critical=0;
			
			if(critical==200)
			{
				critical=0;
				P2= 0xFF;
			  ms_delay(1);
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				blink=0;
	      blink_seven=0;
	      ram_count=0;
	      ram_counts=0;
				desti_change=1;          
	      ready = 1;                                     
	      fire = 0;                          //if in fire we get critical situation then get fire OFF and desti_change=1
	      disp=0; 
	      ram_flip=0;
				ram_flips=0;
				cl=0;        
	      stand_or_not=0;
	      open=0;        
	      seco_speev=0;
	      fan = 0;
				buzz_count=0;
			  stand =0;
	      car_buzzer=0;
	      car_buzzer2=0;
	      ram=0;
	      rams=0;
	      buzzer_on_count=0;
	      car_cancel=0;
			}
		}
		else
			critical=0;
		
		//(time pass time pass time pass time pass time pass time pass)12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12
		if(car_desti==0x00 && maintain==0 && stop==0)              
		{
			ip4 = en_ip_fun(1,1);
			temp=ip4 & 0x01;                   //for car gate
			temp2=ip4 & 0x02;                    //for landing gate
			k=ip4 & 0x80;                         //for D OFF signel
			
			if(temp!=0x01)                      //if car gate is open 
			{
				car_buzzer2++;
				if(car_buzzer2 == 100)
			  {
				  car_buzzer2 = 0;
          buzz=0;
					ms_delay(1);						
			  }
				cam=1;
				ms_delay(1);
				rams=0;
				ram_flips=0;
				ram_counts=0;
				open=1;
			}
			
			else if(temp2 != 0x02 && open==1)     //car gate is closed and then land gate is open
			{
				if(ram_flips == 0)
			  {
          cam=0;
					ms_delay(1);					
				}
			  else
			  {	
			    cam=1;
					ms_delay(1);
			  }
				if(ram_counts != 5)
          rams++;
				
        if(rams == 35)
        {
          rams = 0;
					ram_counts++;
					ram_flips = ~ram_flips;
				}
				if(ram_counts==3)
				{
					buzz=0;
					ms_delay(1);
				}
        if(ram_count==5)
				{
					cam=1;
					ms_delay(1);
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					ram_counts=0;
					rams=0;
					ram_flips=0;
					//open=0;
					if(maintain==0 && maintain==0)
						desti_change=1;
				}	
			}
			else if(temp2==0x02)
		  {
			  open=0;
			  rams=0;
			  ram_flips=0;
			  ram_counts=0;
			  P2 = P2 | 0x09;
			  ms_delay(1);
		  }
		}
			
	//(fan off fan off fan off fan off fan off fan off fan off fan off fan off)13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 
		if(up==1 && down==1)                     
		{
			fan++;
			if(fan==300)
			{
				fan=0;
				//P2 = P2 | 0x10;
				fans=1;
				ms_delay(1);
			}
		}
		else
			fan=0;
		
		//(buzzer off buzzer off buzzer off buzzer off)14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14 14  
		if(buzz==0)
		{
			buzz_count++;
			if(buzz_count == 350 )
			{
				buzz_count=0;
				buzz=1;
				ms_delay(1);
			}
		}
		else 
			buzz_count=0;
		//(LED blink LED blink LED blink LED blink LED blink)15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 
		if(maintain==0)      
		{                                             //when there is no maintainance
		  blink++;
		  if(blink <= 5)                             //to on car_desti LED
			  en_op_fun(0,~call);     
		  else if(blink <= 10)                       //to OFF car_desti LED
		  {
			  temp = call & (~car_desti);
				en_op_fun(0,~temp);
		  }
		  else
			  blink=1;
	  }
		else                                       //in maintainance
		{
			blink++;
			if(blink == 5 || blink == 10 )
     	{
				if(blink == 5)
				{
					ip2=en_ip_fun(0,1);
			    temp=ip2 & 0x03;
				  en_op_fun(0,~temp);
				}
				else
				{
					en_op_fun(0,0xFF);
					blink=0;
				}
			}
		}
		
		//(seven segment seven segment seven segment seven segment seven segment)16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 
		ip4 = en_ip_fun(1,1);                     //for seven_segment
		temp = ip4 & 0x01;
		temp2 = ip4 & 0x02;
		if((temp != 0x01) || (temp2 !=0x02 && car_desti != 0x00) ||  open==1 || maintain==1)
		{
			blink_seven++;
			if(blink_seven <=10)                       //to display floor number
				disp = 0;
			else if(blink_seven <= 20)                //to display "M" or "C" or "L"
			{
				disp = 1;
				if(temp != 0x01)
					cl = 1;
				else
					cl = 0;
			}
			else
				blink_seven=1;
		}
		else
		{
			disp=0;
		}
		en_op_fun(1,op2_fun());
  }	
}

void ms_delay(unsigned int time)
{
	unsigned int i,j;
	for(i=0;i<time;i++)
	for(j=0;j<1275;j++);
}

unsigned char en_ip_fun(bit ip1,bit ip2)
{
	unsigned char temp;
	if(ip1==0 & ip2==0)            //for first eight input  
	{
		en_ip1=0;
		ms_delay(1);
		temp=P0;
		en_ip1=1;
	}
	if(ip1==0 & ip2==1)             //for second eight input
	{
		en_ip2=0;
		ms_delay(1);
		temp=P0;
		en_ip2=1;
	}
	if(ip1==1 & ip2==0)             //for third eight input
	{
		en_ip3=0;
		ms_delay(1);
		temp=P0;
		en_ip3=1;
	}
	if(ip1==1 & ip2==1)             //for four eight input
	{
		en_ip4=0;
		ms_delay(1);
		temp=P0;
		en_ip4=1;
	}
	return temp;
}

void en_op_fun(bit op,unsigned char temp)
{
	if(op==0)                         //for output of first eight LEDs
	{
	  P0=temp;
	  en_op1=1;
	  ms_delay(1);
	  en_op1=0;
	}
	else
	{                                 //for output of seven segment
	  P0=temp;
	  en_op2=1;
	  ms_delay(1);
	  en_op2=0;	
	}
}

unsigned char op2_fun()
{
	unsigned char temp;	//in optput-2 negative logic has been used
	
	ip4 = en_ip_fun(1,1);     //for auto attendent
	temp2= ip4 & 0x04;
	if(temp2 == 0x04)
		temp = 0xAA;
	
	else
	{
	  if(disp==0)
 	  {
	    switch(car)
	    {
		    case 0x01:
		      temp = 0xC0;
		      break;
		    case 0x02:
		      temp = 0xF9;
		      break;
		    case 0x04:
		      temp = 0xA4;
		      break;
		    case 0x08:
		      temp = 0xB0;
		      break;
		    case 0x10:
		      temp = 0x99;
		      break;
		    case 0x20:
		      temp = 0x92;
		      break;
		    case 0x40:
		      temp = 0x82;
		      break;
		    case 0x80:
		      temp = 0xF8;
		      break;
		    default:
			    temp = 0xFF;
	    }
	  }
	  else
  	{
			if(maintain==1)
				temp=0xAA;
			else if(cl==0)
			  temp = 0xC7;
			else
				temp = 0xC6;
	  }
  }
	return temp;	
}
