#include<reg52.h>                                     //header file

sbit en_ip1=P1^4;                                    //all four variables are used to enable inputs buffers
sbit en_ip2=P1^3;
sbit en_ip3=P1^2;
sbit en_ip4=P1^5;

sbit en_op1=P3^0;                                    //all three variables are used to enable output buffers
sbit en_op2=P3^1;

sbit sw1=P3^4;                                       //three switches for floor settings
sbit sw2=P3^5;
sbit sw3=P3^6;

sbit cam=P2^0;                                    //to operate P2 as a single bit
sbit up=P2^1;
sbit buzz=P2^3;
sbit fans=P2^4;
sbit down=P2^5;
sbit seco_spee=P2^6;


unsigned char ip1;                                     //four variables for four inputs
unsigned char ip2;
unsigned char ip3;
unsigned char ip4;

unsigned char car;                                   //a variable showing position of cabin
unsigned char call_car;                              //in call variable if any bit is one then that call is pendind
unsigned char call_lan;                        //in call variable if any bit is one then that call is pendind
unsigned char call;                            //in call variable if any bit is one then that call is pendind
unsigned char car_desti;                   //it is a next destination for car
unsigned char pre_desti;                    //it is a lst attended destination of car

void en_op_fun(bit op,unsigned char temp);         //output function
unsigned char en_ip_fun(bit ip1,bit ip2);          //input function
unsigned char op2_fun();                              //output function for seven segment
void ms_delay(unsigned int time);                     //delay functions

unsigned int fan,stand,car_buzzer,car_buzzer2,ram,rams,buzzer_on_count,critical,car_cancel;
unsigned char i,temp,temp2,k,blink,blink_seven,ram_count,ram_counts,floor,multi;
bit start,desti_change,ready,stop,fire,maintain,AA,disp,ram_flip,ram_flips,cl,stand_or_not,buzzer_on,open,seco_speev;

void main()                                           //output is accordingly negative logic
{
	en_ip1=1;                                          //(negative level trigger)initialisation of enables of input buffers
	en_ip2=1;
	en_ip3=1;
	en_ip4=1;
	
	en_op1=0;                                          //(positive edge trigger)initialisation of enables of output buffers
	en_op2=0;
	   	
	en_op_fun(0,0xFF);                       //initialisation of output port-1
  en_op_fun(1,0xFF);                      //initialisation of output port-2
	P2=0xFF;                                //initialisation of output port-3 
	ms_delay(1);                      
	
	call_car=0x00;                         //call and destination parameters initialisation
	call_lan=0x00;
	call=0x00;
	car_desti=0x00;
	pre_desti=0x00;
	
	fan = 0;                               //integers
	stand =0;
	car_buzzer=0;
	car_buzzer2=0;
	ram=0;
	rams=0;
	buzzer_on_count=0;
	critical=0x00;
	car_cancel=0;
	
	blink=0;                              //chars
	blink_seven=0;
	ram_count=0;
	ram_counts=0;
	
	start=0;                             //to ckeck till when we need to drive the car till it ends to one of the the floor
	desti_change=1;                      //desination can be changed
	ready = 1;                           //car is ready to take second call                      
	fire = 0;                            //if fire button is once pressed it becomes 1
	maintain = 0;                        //if maintainance bits of ip is high then it is high
	AA=0;                               //if maintainance bits of ip is high then it is high
	disp=0;                             //if bits is 0 then it display floor otherwise display othen thing
	ram_flip=0;                         //if bits is 0 then cam is ON otherwise it is OFF 
	ram_flips=0;                        //if bits is 0 then cam is ON otherwise it is OFF
	cl=0;                               //if cl==1 then dispaly "C" otherwise "L"
	stand_or_not=0;                     //for standing delay
	buzzer_on=0;                        //to ON buzzer
	open=0;                             //to dispaly landing door after closing car door
	seco_speev=0;                       //for mis match of D OFF ip
	
	temp2 = P3 & 0x70;                  //to decide how many floors are there
	switch(temp2)
	{
	  case 0x60:
		{
			floor=0x83;
			multi=0x02;
			break;
		}
		case 0x50:
		{
			multi=0x04;
			floor=0x87;
			break;
		}
		case 0x40:
		{
			multi=0x08;
			floor=0x8F;
			break;
		}
		case 0x30:
		{
			multi=0x10;
			floor=0x9F;
			break;
		}
		case 0x20:
		{
			multi=0x20;
			floor=0xBF;
			break;
		}
		case 0x10:
		{
			multi=0x40;
			floor=0xFF;
			break;
		}
		case 0x00:
		{
			multi=0x80;
			floor=0xFF;
			break;
		}
		default:
		{
			floor=0x00;
			multi=0;
		}
	}	
	
	//1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
	ip1=en_ip_fun(0,0);
	ip1 = ip1 & floor;
	ip4=en_ip_fun(1,1);
	
	temp = ip4 & 0x80;
	if(temp != 0x80 || ip1 == 0x00) 
	{
		while(start!=1)
		{
      ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x01;     //for car door
			temp2 = ip4 & 0x02;    //for landing door
			i = ip4 & 0x40;        //stop
			k= ip4 & 0x20;         //maintainance
			
			if(i == 0x40)         //for stop
			{
				 P2= 0xFF;
			   ms_delay(1);
				 ram=0;
				 ram_flip=0;
				 ram_count=0;
			}
			else
			{
			  if(k==0x20)            //for maintainance
			  {
					maintain=1;
				  
					ip2 = en_ip_fun(0,1);
					temp = ip2 & 0x03;    //to take command of up or down in maintainance
				
				  en_op_fun(0,~temp);  //to indicate at op1 in maintainance
				
				  ip4=en_ip_fun(1,1);
		      temp2=ip4 & 0x03;
				
					if(temp == 0x01)
		      {
						if(cam==1)
						{
						  cam=0;
              ms_delay(40);
						}
            P2 = 0xDE;
            ms_delay(1);							
 	        }
			    else if(temp == 0x02)
			    {
						if(cam==1)
						{
			        cam=0;
						  ms_delay(40);
						}
						P2=0xFC;
						ms_delay(1);
		      }
					else
					{
						if(cam==0)
						{
						  cam=1;
						  ms_delay(40);
						}
					  P2=0xFF;
			      ms_delay(1);
					}
			  }
				else if(maintain==1 && k!=0x20)
				{
					maintain=0;
					P2 = 0xFF;
					ram=0;
					ram_flip=0;
					ram_count=0;
					en_op_fun(0,0xFF);
					ms_delay(1000);
				}
	
			  else if(temp == 0x01 && temp2 == 0x02)
			  {
				  ram_count=0;
				  ram=0;
				  ram_flip=0;
					if(cam==1)
					{	
			      cam=0;
					  ms_delay(40);
					}
			    P2 = 0x8E;
          ms_delay(1);				
			  }
				
			  else if(temp == 0x01 && temp != 0x02)
			  {
				  P2 = P2 | 0x72;               //stop up and down command
				  ms_delay(1);
				  if(ram_flip == 0)
				  {
            cam=0;
						ms_delay(1);					
				  }
				  else
				  {	 
						cam=1;
				    ms_delay(1);
				  }
				  if(ram_count != 5)
            ram++;
          if(ram == 25)
          {
            ram = 0;
					  ram_count++;
					  ram_flip = ~ram_flip;
				  }
          if(ram_count==5)
			 	  {
						buzz=0;
					  ms_delay(1);
				  }					
			  }	
				
        else
			  {
				  ram_count=0;
				  ram=0;
				  ram_flip=0;
				  P2 = P2 | 0x73;
				  ms_delay(1);
          car_buzzer++;
				  if(car_buzzer == 300)
				  {
					  car_buzzer = 0;
						buzz=0;
            ms_delay(1);					
				  }
			  }
		  }
			
			ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x01;
			temp2 = ip4 & 0x02;
			k= ip4 & 0x20;     //maintainance
			
			if(k==0x20)
			  en_op_fun(1,0xAA);
			else if(temp!=0x01)
				en_op_fun(1,0xC6);
			else if(temp2!=0x02)
				en_op_fun(1,0xC7);
			else
				en_op_fun(1,0xFF);
			
      ip4 = en_ip_fun(1,1);
      temp = ip4 & 0x80;
			
			ip1=en_ip_fun(0,0);
			ip1 = ip1 & floor;
			
      if(temp == 0x80 && ip1 != 0x00)
        start =1;
	  }
	}
	
	P2 = 0xFF;
	ms_delay(1);
  ip1 = en_ip_fun(0,0);
	ip1 = ip1 & floor;
	temp = ip1 & 0x80;
	if(temp != 0x00)
	{
		ip1 = ip1 | multi;
		ip1 = ip1 & 0x7F;
	}
	car=ip1;
	en_op_fun(1,op2_fun());
	maintain=0;
	ram=0;
	ram_count=0;
	ram_flip=0;
	
	while(1)
	{
		//2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 
		ip1=en_ip_fun(0,0);
		ip1 = ip1 & floor;
		
		temp = ip1 & 0x80;
		if(temp != 0x00)
		{
			ip1 = ip1 | multi;
			ip1 = ip1 & 0x7F;
		}
		if(ip1!=0x00 && ip1!=0x01 && ip1!=0x02 && ip1!=0x04 && ip1!=0x08 && ip1!=0x10 && ip1!=0x20 && ip1!=0x40 && ip1!=0x80 && fire==0 && maintain==0)
		{
			P2=0xFF;
			ms_delay(1);
			P2= 0xFF;
			ms_delay(1);
		  call_car = 0x00;
		  call_lan = 0x00;
			call = 0x00;
			car_desti = 0x00;
			fan=0;
			stand=0;
			car_buzzer=0;
			car_buzzer2=0;
			ram=0;
			ram_count=0;
			ram_flip=0;
			buzzer_on_count=0;
			critical=0;
			desti_change=1;
			ready=1;
			buzzer_on=0;
		}
		else if(ip1 != 0x00)
		{	
		  car=ip1;
			ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x80;
			temp2 = ip4 & 0x03;
			if(car == car_desti && seco_spee ==1 && temp != 0x80 && temp2 == 0x03)
			{
				seco_spee=0;
				ms_delay(1);
				desti_change=0;
			}
			if(car!=car_desti && seco_spee==0 && temp2 == 0x03)
			{
				car_desti = car;
				call_car = call_car | car;
				call = call_car | call_lan;
			}
		}
		//3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
		ip2=en_ip_fun(0,1);                 
		ip2 = ip2 & floor;
		ip2= ip2 & (~car);
		call_car= call_car | ip2;
		//4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
		ip3=en_ip_fun(1,0);                   
		ip3 = ip3 & floor;
		ip3 =ip3 & (~car);
		call_lan= call_lan | ip3;
		
		call= call_car | call_lan;
		//5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
		if(call != 0x00 && desti_change==1)    //***********************************************************************************************************************************************************************
		{
		  if(up==1 && down==1)                                //if car is stop******************************************************************************************************************************************
		  {
			  if(call_car != 0x00 && call_lan != 0x00)         //both car and lan call at a time
			  {
					if(car > call_car && car > call_lan)           //(3.2)car will go down because call_car is down and call_lan is down
					{
						temp = call_car | call_lan;
						for(i=0;i<8;i++)
						{
							temp2 = temp & (0x80 >> i);
							if(temp2 != 0x00)
								break;
						}
						car_desti=temp2;
					}
					else                                          //car will go up bcoz atleast one call is upwards
					{                                             
						if(call_car > car)                          //(3.1,3.3)car will go to lowest call_car higher than car
						{
						  for(i=0;i<8;i++)
						  {
							  temp = car & (0x01 << i);
							  if(temp != 0x00)
								  break;
						  }
						  for(k=i+1 ; k<8 ; k++)
						  {
							  temp = call_car & (0x01 << k);
							  if(temp != 0x00)
								  break;
						  }
							car_desti = temp;
					  }
						else                                         //(3.4)car will go up to attend call_lan
							{
							  for(i=0;i<8;i++)
							  {
								  temp = call_lan & (0x80>>i);
								  if(temp != 0x00)
									  break;
							  }
							  car_desti = temp;
						  }
					  }
			    }
			    else if(call_lan != 0x00)                        //both lan call is at a time
				  {
					  if(call_lan > car)                              //(2.1,2.3)car will go up
					{
						for(i=0;i<8;i++)
						{
							temp = call_lan & (0x80 >> i);
							if(temp != 0x00)
								break;
						}
						car_desti = temp;
					}
					else                                            //(2.2)car will go down
					{
						for(i=0;i<8;i++)
						{
							temp = car & (0x80 >> i);
							if(temp != 0x00)
								break;
						}
						for(k=i+1 ; k<8;k++)
						{
							temp = call_lan & ( 0x80 >> k);
							if(temp != 0x00)
								break;
						}
						car_desti = temp;
					}
				}
				else if(call_car != 0x00)                         //both call_car at a time
				{
					if(call_car < car)                               //(1.2)car will go down
					{
						for(i=0;i<8;i++)
						{
							temp = call_car & (0x80>>i);
							if(temp != 0x00)
								break;
						}
						car_desti = temp;
					}
					else                                             //(1.1,1.3)car will go up
					{
						for(i=0;i<8;i++)
						{
							temp = car & (0x01 << i);
							if(temp != 0x00)
								break;
						}
						for(k=i+1;k<8;k++)
						{
							temp = call_car & (0x01 << k);
							if(temp != 0x00)
								break;
						}
						car_desti=temp;
					}
				}
		  }
		  else if(up==0)                           //if car is going up****************************************************************************************************************************************************
		  {
				if(call_car != 0x00)                   //there ia at least one call_car
				{
					for(i=0;i<8;i++)
					{
						temp = car & (0x01 << i);
						if(temp != 0x00)
							break;
					}
					for(k=i+1;k<8;k++)
					{
						temp = call_car & (0x01 << k);
						if(temp != 0x00)
							break;
					}
					car_desti=temp;
				}	
        else                                   //there is no call_car only call_lan
				{
          for(i=0;i<8;i++)
					{
						temp = call_lan & (0x80>>i);
						if(temp != 0x00)
							break;
					}
					car_desti=temp;
				}					
		  }
		  else if(down==0)                          //if car is going down****************************************************************************************************************************************************
		  {
				temp = call_car | call_lan;
				for(i=0;i<8;i++)
				{
					temp2 = car & (0x80>>i);
					if(temp2 != 0x00)
						break;
		    }
				for(k=i+1;k<8;k++)
				{
					temp2 = temp & (0x80 >> k);
					if(temp2 != 0x00)
						break;
				}
				car_desti = temp2;
			}
		  else                                       //if critical condition
		  {
			  P2=0xFF;
			  ms_delay(2);
	    }
			temp = car_desti & call;
			if(temp == 0x00)
			{
				//P2 = P2 & 0xBF;
				seco_spee=0;
				ms_delay(1);
			}
		}
	  
		
		
		//(101010101010101010101010101010101010101010101010101010101010101)6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6
		ip4=en_ip_fun(1,1); 
		
		if(ready == 1 && car_desti != 0x00)
		{
			ip4 = en_ip_fun(1,1);
			temp = ip4 & 0x01;
			temp2 = ip4 & 0x02;
			if(temp == 0x01 && temp2 == 0x02)
			{
				if(cam==1)
				{
				  cam=0;
			    ms_delay(40);	
				}
				ram=0;
				ram_flip=0;
				ram_count=0;
				if(car < car_desti)
			    {
			      P2=0xEC;
			      ms_delay(1);
		      }
		    else if (car > car_desti)
		      {
			      P2=0xCE;
				    ms_delay(1);
			    }
        if(seco_spee==0)
				{
          if(pre_desti < car_desti)
			    {
			      P2=0xAC;
			      ms_delay(1);
		      }
		    else if (pre_desti > car_desti)
		      {
			      P2=0x8E;
				    ms_delay(1);
			    }
				}					
			}
			else if(temp == 0x01 && temp != 0x02)
			{
				P2 = P2 | 0x62;
				ms_delay(1);
				fans=0;
				ms_delay(1);
				if(ram_flip == 0)
				{
					cam=0;
					ms_delay(1);					
				}
				else
				{	
				  cam=1;
					ms_delay(1);
			  }
			 	if(ram_count != 5)
          ram++;
        if(ram == 25)
        {
          ram = 0;
					ram_count++;
					ram_flip = ~ram_flip;
				}
				if(ram_count==3)
				{
					buzz=0;
					ms_delay(1);
				}
        if(ram_count==5)
				{
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					ram_count=0;
					ram=0;
					ram_flip=0;
					if(maintain==0 && fire==0)
						desti_change=1;
					cam=1;
					ms_delay(1);
					buzzer_on=1;
				}					
			}	
      else
			{
				P2 = P2 | 0x63;
				ms_delay(1);
				fans=0;
				ms_delay(1);
				ram=0;
				ram_flip=0;                    //cahnge cahneg change change change
				ram_count=0;
				
        car_buzzer++;
				if(car_buzzer == 100)
				{
					car_buzzer = 0;
          buzz=0;
					ms_delay(1);					
				}
				
				car_cancel++;
				if(car_cancel==250)
				{
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					car_cancel=0;
				}
			}
		}
		
		
		/*ip4=en_ip_fun(1,1);                          //AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA AA
		temp = ip4 & 0x04;
		if(temp == 0x04)
		{//dont use temp inside the function
			if(AA==0)
			{
				AA=1;
			  desti_change=0;
			  call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				main_desti_change=1;
			}
			else
			{
				if(call_car != pre_desti)
				{
					P2 = P2 & 0x7F;
					ms_delay(10);
				}
				pre_desti=call_car;
				
			}
		}
		else if(temp != 0x04 && AA==1)
		{
			AA=0;
			desti_change=1;
			pre_desti=0x00;
		}*/
		
		//(fire fire fire fire fire fire fire fire fire fire)7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 
		ip4 = en_ip_fun(1,1);                
		temp = ip4 & 0x10;
		if((temp == 0x10 && maintain==0) | fire==1)
		{
			if(fire==0)
			{
				P2= 0xFF;
			  ms_delay(1);
				desti_change=0;
				call_car = 0x01;
		    call_lan = 0x00;
			  call = 0x01;
			  car_desti = 0x01;
				fire=1;
				ready=1;
			}
			desti_change=0;
			call_car = 0x01;
		  call_lan = 0x00;
			call = 0x01;
			car_desti = 0x01;
			ready=1;
		}
		
		
		//(maintain maintain maintain maintain maintain maintain maintain)8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8
		ip4 = en_ip_fun(1,1);
		temp = ip4 & 0x20;
		if(temp == 0x20 && fire==0)
		{
			if(maintain==0)
			{
				P2= 0xFF;
				ms_delay(1);
				desti_change=0;
				maintain=1;
				ready=0;
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
			}
			else
			{
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				ip2 = en_ip_fun(0,1);
		    k = ip2 & 0x03;
				
				en_op_fun(0,~k);
				
				ip4=en_ip_fun(1,1);
		    temp2=ip4 & 0x43;
				
				if(temp2 == 0x03)
			  {
					if(k == 0x01)
		        {
              if(cam==1)
							{
								cam=0;
							  ms_delay(40);
							}
              P2 = 0xDE;
              ms_delay(1);							
 	          }
			      else if(k == 0x02)
			      {
							if(cam==1)
							{
			          cam=0;
							  ms_delay(40);
							}
							P2=0xFC;
							ms_delay(1);
		        }
					else
					{
						if(cam==0)
						{
						  cam=1;
						  ms_delay(40);
						}
					  P2=0xFF;
			      ms_delay(1);
					}
			  }
				else
			  {
			    P2=0xFF;
				  ms_delay(1);
		    }
		  }
		}
		else if(temp != 0x20 && maintain==1)
		{
			maintain=0;
			ready=1;
			desti_change=1;
			ms_delay(1000);
		}
		
	
		temp = ip4 & 0x40;                        //stopstopstopstopstopstopstopstopstop
		if(temp == 0x40)
		{
			if(stop==0)
			{
			  P2= 0xFF;
			  ms_delay(1);
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				stop=1;
				desti_change=0;
				ready=0;
			}
			else
			{
				P2= 0xFF;
			  ms_delay(1);
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
			}
		}
		else if(temp!=0x40 && stop==1)
		{
			stop=0;
			if(fire==0 && maintain==0)
			{
				ready=1;
			  desti_change=1;
			}
			else if(maintain==1)
			{
				P2= 0xFF;
			  ms_delay(1);
				desti_change=0;
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				ready=0;
			}
			else if(fire==1)
			{
				P2= 0xFF;
			  ms_delay(1);
				desti_change=0;
				call_car = 0x01;
		    call_lan = 0x00;
			  call = 0x01;
			  car_desti = 0x01;
				ready=1;
			}
		}
	
	
		temp = ip4 & 0x80;                       //777777777777777777777777777777777777777777777777777777
		if(temp == 0x80)
		{
			if(seco_spee == 0)
			{ 
        P2=0xEE;
			  ms_delay(40);
				//P2 = P2 | 0x01;
				ram=1;
				ms_delay(1);
				
			//	seco_speev=1;
				
				call_car = call_car & (~car);
			  call_lan = call_lan & (~car);
				call=call_car | call_lan;
				pre_desti=car_desti;
				car_desti=0x00;
				ip4 = en_ip_fun(1,1);              //for lift man and fire
		    temp = ip4 & 0x04;
			  if(temp == 0x00 && fire==0 && maintain==0)                      
		      desti_change=1;
				
				stand_or_not=1;
			}
			/*if(stand_or_not==1)
			{
				stand++;
				if(stand==100)
				{
					stand=0;
					ready=1;
					stand_or_not=0;
				}
				else 
					ready=0;
			}*/
		}
		
		//if(seco_speev==1)
	//	{
			if(stand_or_not==1)
			{
				stand++;
				if(stand==100)
				{
					stand=0;
					ready=1;
					stand_or_not=0;
				}
				else 
					ready=0;
			}
		//}
		
		
		//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
		
	  if(up==0 || down==0)                           //critical critical critical critical
		{
			ip1=en_ip_fun(0,0);
			ip1 =ip1 & floor;
			if(ip1==0x00)
			{
				critical++;
			}
			else
			{
				critical=0;
			}
			if(critical==200)
			{
				critical=0;
				P2= 0xFF;
			  ms_delay(1);
				call_car = 0x00;
		    call_lan = 0x00;
			  call = 0x00;
			  car_desti = 0x00;
				fire=0;
			}
		}
		else
			critical=0;
		////////////////////////////////////////////////////////////////////////////////////////
		if(car_desti==0x00 && maintain!=1)             //time pass time pass time pass 
		{
			ip4 = en_ip_fun(1,1);
			temp=ip4 & 0x01;
			temp2=ip4 & 0x02;
			k=ip4 & 0x80;
			
			//P2 = P2 | 0x62;
			//ms_delay(1);
			
			if(temp!=0x01)
			{
				car_buzzer2++;
				if(car_buzzer2 == 100)
			  {
				  car_buzzer2 = 0;
				  //P2 = P2 & 0xF7;
          buzz=0;
					ms_delay(1);						
			  }
				//P2 = P2 | 0x01;
				cam=1;
				ms_delay(1);
				ram=0;
				ram_flip=0;
				ram_count=0;
				open=1;
			}
			
			else if(temp2 != 0x02 && open==1)
			{
			//	if(k == 0x80)
				//{
				  if(ram_flip == 0)
				  {
				    //P2 = P2 & 0xFE;
            cam=0;
						ms_delay(1);					
				  }
				  else
				  {	
				    //P2 = P2 | 0x01; 
				    cam=0;
						ms_delay(1);
			  	}
			  //}
			//	else
	//			{
		//		  P2 = P2 | 0x01;
			//	  ms_delay(1);	
				//}
				if(ram_count != 5)
          ram++;
        if(ram == 100)
        {
          ram = 0;
					ram_count++;
					ram_flip = ~ram_flip;
				}
				if(ram_count==3)
				{
					//P2 = P2 & 0xF7;         //to on buzzer
					buzz=0;
					ms_delay(1);
				}
        if(ram_count==5)
				{
					open=0;
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					//P2 = P2 | 0x01;
					cam=1;
					ms_delay(1);
					buzzer_on=1;
				}	
			}
			 else if(temp2==0x02)
		 {
			 open=0;
			 ram=0;
			 ram_flip=0;
			 ram_count=0;
			 P2 = P2 | 0x09;
			 ms_delay(1);
		 }
			
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	/*	if(up==1 && down==1 && car_desti==0x00)                                    //open open open open 
		{
			ip4 = en_ip_fun(1,1);
			temp=ip4 & 0x01;
			temp2=ip4 & 0x02;
			k=ip4 & 0x80;
			if(temp!=0x01)
			{
				open=1;
				rams=0;
				ram_flips=0;
				ram_counts=0;
			}
			else if(open==1 && temp2 != 0x02)
			{////////////////////////////////////////////////////////////////
				if(k == 0x80)
				{
				  if(ram_flips == 0)
				  {
				    P2 = P2 & 0xFE;
            ms_delay(1);					
				  }
				  else
				  {	
				    P2 = P2 | 0x01; 
				    ms_delay(1);
			  	}
			  }
				else
				{
				  P2 = P2 | 0x01;
				  ms_delay(1);	
				}
				if(ram_counts != 5)
          rams++;
        if(rams == 100)
        {
          rams = 0;
					ram_counts++;
					ram_flips = ~ram_flips;
				}
				if(ram_counts==3)
				{
					P2 = P2 & 0xF7;         //to on buzzer
					ms_delay(1);
				}
        if(ram_counts==5)
				{
					open=0;
					call_car = 0x00;
				  call_lan = 0x00;
				  call = 0x00;
				  car_desti = 0x00;
					P2 = P2 | 0x01;
					ms_delay(1);
					buzzer_on=1;
				}					
			}	
     else if(temp2==0x02)
		 {
			 open=0;
			 rams=0;
			 ram_flips=0;
			 ram_counts=0;
			 P2 = P2 | 0x01;
			 ms_delay(1);
		 }
				
			}/////////////////////////////////////////////////////////////
		
		
		
		
		if(car_desti == 0x00)                                      //for car_buzzer2
		{
		ram=0;
			ram_flip=0;
		ram_count=0;
			ip4 = en_ip_fun(1,1);
		  temp = ip4 & 0x01;
		  if(temp != 0x01)
		  {
			  P2 = P2 | 0x73;
			  ms_delay(1);
        car_buzzer2++;
			  if(car_buzzer2 == 100)
			  {
				  car_buzzer2 = 0;
				  P2 = P2 & 0xF7;
          ms_delay(1);					
			  }
		  }
		  else
		  {
				if(buzzer_on==0)
				{
				  P2 = P2  | 0x08; 
			    car_buzzer2 = 0;
				}
				if(buzzer_on==1)
				{
					buzzer_on_count++;
					if(buzzer_on_count==200)
					{
						buzzer_on_count=0;
						buzzer_on=0;
					}
				}
		  }
		}*/
	
		
		
		if(up==1 && down==1)                     //to off fan to save power
		{
			fan++;
			if(fan==500)
			{
				fan=0;
				//P2 = P2 | 0x10;
				fans=1;
				ms_delay(1);
			}
		}
		else
			fan=0;
		
		/*blink++;                               //for bilnking of op1 of car_desti
    if(blink == 5 || blink == 10 )
    {
			if(blink == 5)                 
		  en_op_fun(0,~call);                                                //change 
			else
			{
				blink = 0;
				temp = call & (~car_desti);
				en_op_fun(0,~temp);
				//en_op_fun(0,car_desti); 
			} 			
		}*/
		if(maintain==0)
		{
		  blink++;
		  if(blink <= 5)
		  {
			  en_op_fun(0,~call);     
	 	  }
		  else if(blink <= 10)
		  {
			  temp = call & (~car_desti);
				en_op_fun(0,~temp);
		  }
		  else
			  blink=1;
	  }
		
		ip4 = en_ip_fun(1,1);                     //for seven_segment
		temp = ip4 & 0x01;
		temp2 = ip4 & 0x02;
		if((temp != 0x01) || (temp2 !=0x02 & car_desti != 0x00) || (temp2 !=0x02 & open==1) || maintain==1)
		{
			blink_seven++;
			if(blink_seven == 10 || blink_seven == 20)
			{
				if(blink_seven == 10)
					disp=0;
				else
				{
					blink_seven = 0;
					disp = 1;
					if(temp != 0x01)
						cl = 1;
					else
						cl = 0;
				}
			}
		}
		else
		{
			disp=0;
		}
		en_op_fun(1,op2_fun());
  }	
}

void ms_delay(unsigned int time)
{
	unsigned int i,j;
	for(i=0;i<time;i++)
	for(j=0;j<1275;j++);
}

unsigned char en_ip_fun(bit ip1,bit ip2)
{
	unsigned char temp;
	if(ip1==0 & ip2==0)
	{
		en_ip1=0;
		ms_delay(1);
		temp=P0;
		en_ip1=1;
	}
	if(ip1==0 & ip2==1)
	{
		en_ip2=0;
		ms_delay(1);
		temp=P0;
		en_ip2=1;
	}
	if(ip1==1 & ip2==0)
	{
		en_ip3=0;
		ms_delay(1);
		temp=P0;
		en_ip3=1;
	}
	if(ip1==1 & ip2==1)
	{
		en_ip4=0;
		ms_delay(1);
		temp=P0;
		en_ip4=1;
	}
	return temp;
}

void en_op_fun(bit op,unsigned char temp)
{
	if(op==0)
	{
	  P0=temp;
	  en_op1=1;
	  ms_delay(1);
	  en_op1=0;
	}
	else
	{
	  P0=temp;
	  en_op2=1;
	  ms_delay(1);
	  en_op2=0;	
	}
}

unsigned char op2_fun()
{
	unsigned char temp;	//in optput-2 negative logic has been used
	
	ip4 = en_ip_fun(1,1);     //for auto attendent
	temp2= ip4 & 0x04;
	if(temp2 == 0x04)
		temp = 0xAA;
	
	else
	{
	  if(disp==0)
 	  {
	    switch(car)
	    {
		    case 0x01:
		      temp = 0xC0;
		      break;
		    case 0x02:
		      temp = 0xF9;
		      break;
		    case 0x04:
		      temp = 0xA4;
		      break;
		    case 0x08:
		      temp = 0xB0;
		      break;
		    case 0x10:
		      temp = 0x99;
		      break;
		    case 0x20:
		      temp = 0x92;
		      break;
		    case 0x40:
		      temp = 0x82;
		      break;
		    case 0x80:
		      temp = 0xF8;
		      break;
		    default:
			    temp = 0xFF;
	    }
	  }
	  else
  	{
			if(maintain==1)
				temp=0xAA;
			else if(cl==0)
			  temp = 0xC7;
			else
				temp = 0xC6;
	  }
  }
	return temp;	
}
